---
title: 虚拟货币交易系统
date: 2026-01-07
icon: money-check-dollar
---





## 虚拟货币交易系统



### 一、基础软件安装

##### 1、在阿里云服务器安装RocketMQ

	1. 创建docker network

```
# 1. 创建自定义网络
docker network create rocketmq-net
```



​	2. 安装rocketmq-namesrv

```dockerfile
# NameServer
docker run --name namesrv \
  --network rocketmq-net \
  -p 9876:9876 \
  -e "MAX_POSSIBLE_HEAP=100000000" \
  -d rocketmqinc/rocketmq \
  sh mqnamesrv
```



 3. 安装broker

    broker.conf

> brokerName = broker-a
> brokerId = 0
> deleteWhen = 04
> fileReservedTime = 48
> brokerRole = ASYNC_MASTER
> flushDiskType = ASYNC_FLUSH

```
docker run --name broker \
  --network rocketmq-net \
  -p 10911:10911 -p 10909:10909 \
  -v /opt/rocketmq/broker.conf:/opt/rocketmq-4.4.0/conf/broker.conf \
  -e "NAMESRV_ADDR=namesrv:9876" \
  -e "MAX_POSSIBLE_HEAP=200000000" \
  -d rocketmqinc/rocketmq:4.4.0 \
  sh mqbroker -c /opt/rocketmq-4.4.0/conf/broker.conf

```



 	3. 安装可视化页面

```
docker run --name rocketmq-console \
  --network rocketmq-net \
  -e "JAVA_OPTS=-Drocketmq.namesrv.addr=namesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false" \
  -p 8081:8080 \
  -d styletang/rocketmq-console-ng
```



##### 2、在阿里云安装MongoDB

```
docker run --name mongo -p 27017:27017 -d mongo --auth
```



##### 3、在阿里云安装sentinel

```
docker run --name sentinel  -p 8858:8858 -d  bladex/sentinel-dashboard
```

如果你想要修改默认的账号和密码，你可以exec进入到这个容器中，然后在app.jar目录下创建一个application.properties文件,然后修改你的用户名和密码即可

> auth.username=sentinel
> auth.password=sentinel

```
java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar
```



##### 4、在阿里云安装senta

```
docker run -d --name seata-server -p 8091:8091  -e SEATA_IP=39.97.35.197  seataio/seata-server
```



### 二、架构设计图以及模块划分

##### 1.架构设计

![架构设计图](https://s3.bmp.ovh/imgs/2025/12/16/60947c77b84f4f10.png)



##### 2.模块划分

![模块划分](https://s3.bmp.ovh/imgs/2025/12/16/025623aa8ad9cf57.png)





### 三、基础服务层Iaas层

#### 		1. OAuth2授权服务器演进方案

​	传统标准的OAuth2.0协议，资源服务器一般在接收到用户的请求的时候，会用用户请求携带的Token去访问授权服务器的 **/oauth/check_token** 这个暴露的endpoints来进行认证。

​	但是如果我们的访问量非常大的话，会有一个问题： **每次请求都会调用一次授权服务器，会大大增加授权服务器的压力**

​	针对这种问题的解决方案就是我们资源服务器不要再去授权服务器进行认证了，自己就可以进行认证，那么这个怎么实现呢？这就需要授权服务器在生成Token的时候**使用JWT来生成Token** 。这样资源服务器自己就可以获取到用户的信息。但是随之又带来一个新的问题： **JWT方案的登出问题** 。说的通俗点来说，比如我们修改了这个用户的权限，或者将这个用户踢下线，那么这个老token在有效期内依然可以使用的。

​	针对 JWT方案的登出问题，我的解决方案是：

> 结合Redis，将jwt生成的token放在Redis中，当进行权限修改、踢人下线、登出的时候去Redis中删除。然后在网关中增加一个全局拦截器，拦截请求，如果这个请求不在白名单中，则拿到header中的Authorization的Token,然后判断Redis中是否存在这个Token,如果存在说明正常，如果不存在说明这个Token非法。



补充： 补充一下生成非对称密钥的命令

> #生成私钥
>
> keytool -genkeypair -alias coinexchange -keyalg RSA -keypass coinexchange -keystore coinexchange.jks -validity 365 -storepass coinexchange
>
> #生成公钥
>
> keytool -list -rfc --keystore coinexchange.jks | openssl x509 -inform pem -pubkey



​	在这里记录一个我们系统使用spring cloud oauth2来整合JWT方案的一个**特点**。正常情况下JWT负载payload中的内容是所有人都可以看到的，OAuth2整合JWT**默认是将username放在payload的user_name中的**，我们资源服务器在拿到用户请求传递过来的Token的时候是需要进行jwt的解析的，我们需要用到这个user_name来进行一系列的操作，比如查询、保存等等，所以如果我们保存的是用户名，那么后续肯定是无法使用的，因为我们的唯一键一般都是user_id而不是user_name，所以我们系统中进行了一个转换，我们**将sys_user表中的id来存储到user_name中**。

​	但是**随之带来了一个问题**，那就是当我们使用**grant_type=refresh_token**方式来授权服务器请求获取新的Token的时候，我们的这个user_name是无法查询到用户信息的，**因为我们payload中的user_name中放的是sys_user的id**，所以也就无法来生成新的Token，所以我们针对**grant_type=refresh_token**的请求进行了特殊处理，我们又去查了一次sys_user表，**将username来替换payload中的user_name**。



> RBAC的表结构是一个规范！！！



​	另外我还想记录一种情况，就是当第三方客户端不是通过用户登录来访问我们资源服务器的时候也是需要Token数据的（比如定时任务），但是此时没有username和password，那么如何来获取Token呢，**OAuth2已经帮我们默认做了实现**，其实我们**只需要增加一个第三方客户端**然后**指定grant_type**为固定的类型**client_credentials**就可以了。

```java
/**
 * @description: 授权服务器配置
 * @author: carl
 * @date: 2025.12.16
 * @Since: 1.0
 */
@EnableAuthorizationServer
@Configuration
public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {
    @Resource
    private UserDetailsService userDetailsService;

    @Resource
    private AuthenticationManager authenticationManager;
    @Autowired
    private PasswordEncoder passwordEncoder;


    /**
     * 配置第三方授权客户端
     *
     * @param clients the client details configurer
     * @throws Exception
     */
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
//                客户端名称
                .withClient("coin-exchange")
//                密钥,因为我们使用了BCryptPasswordEncoder所以在指定密钥的时候需要加密一下
                .secret(passwordEncoder.encode("coin-secret"))
//                token有效时间
                .accessTokenValiditySeconds(3600)
//                refresh token的有效期
                .refreshTokenValiditySeconds(7 * 3600)
                .scopes("all")
//                设置这个第三方客户端的grant_type有那些
                .authorizedGrantTypes("password","refresh_token")
                //下面我们增加了一个第三方的客户端，这个是用来干嘛的呢，
                // 是当第三方不用由用户发起的请求，比如定时任务来请求我们系统的时候，如果来进行授权
                .and()
                .withClient("inside-app")
                .secret(passwordEncoder.encode("inside-secret"))
                //关键就是增加一个授权type就可以了,固定类型！！！
                .authorizedGrantTypes("client_credentials")
                .scopes("all")
                .accessTokenValiditySeconds(3600);
        super.configure(clients);
    }

    /**
     * 配置验证服务器
     * 使用JWT方案来生成token
     *
     * @param endpoints the endpoints configurer
     * @throws Exception
     */
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        endpoints.authenticationManager(authenticationManager)
                .userDetailsService(userDetailsService)
                //通过JWT来生成token
                .tokenStore(createTokenStore())
                //指定token增强器
                .tokenEnhancer(jwtAccessTokenConverter());
        super.configure(endpoints);
    }

    private JwtTokenStore createTokenStore() {
        return new JwtTokenStore(jwtAccessTokenConverter());
    }

    private JwtAccessTokenConverter jwtAccessTokenConverter() {
        JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter();
        ClassPathResource classPathResource = new ClassPathResource("coinexchange.jks");
        KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(classPathResource, "coinexchange".toCharArray());
        KeyPair keyPair = keyStoreKeyFactory.getKeyPair("coinexchange", "coinexchange".toCharArray());
        jwtAccessTokenConverter.setKeyPair(keyPair);
        return jwtAccessTokenConverter;
    }


}
```





---





### 四、公共依赖Common层

​	在这一模块中，我主要记录一下一些通用的组件的配置

#### 1.  jackson配置

```java
/**
 * @description: jackson序列化配置
 * @author: carl
 * @createDate: 2025-12-18 20:10
 * @Since: 1.0
 */
@Configuration
public class JacksonConfig {
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        //设置Long类型序列话为String类型
        SimpleModule simpleModule = new SimpleModule();
        simpleModule.addSerializer(Long.class, ToStringSerializer.instance);
        objectMapper.registerModule(simpleModule);
        //设置日期格式
        objectMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
        //设置时区
        objectMapper.setTimeZone(TimeZone.getTimeZone("Asia/Shanghai"));
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        return objectMapper;
    }
}
```



#### 2. mybatis-plus配置

```java
/**
 * @description: mybatis-plus配置
 * @author: carl
 * @createDate: 2025-12-18 20:23
 * @Since: 1.0
 */
@Configuration
public class MybatisPlusConfig {
    /**
     * 分页插件配置
     *
     * @return
     */
    @Bean
    public PaginationInterceptor paginationInterceptor() {
        PaginationInterceptor paginationInterceptor = new PaginationInterceptor();
        paginationInterceptor.setDbType(DbType.MYSQL);
        return paginationInterceptor;
    }


    /**
     * 乐观锁配置
     */
    @Bean
    public OptimisticLockerInterceptor optimisticLockerInterceptor() {
        return new OptimisticLockerInterceptor();
    }

    /**
     * ID生成器配置
     */
    public IKeyGenerator iKeyGenerator() {
        //H2KeyGenerator支持通过序列来生成id
        H2KeyGenerator h2KeyGenerator = new H2KeyGenerator();
        return h2KeyGenerator;
    }
}
```



#### 3. redis配置

```java
/**
 * @description: Redis序列化配置
 * @author: carl
 * @createDate: 2025-12-18 20:18
 * @Since: 1.0
 */
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }
}
```



#### 4. OAuth2协议中资源服务器的配置

```java
/**
 * @description: OAuth2协议中的资源服务器配置
 * @author: carl
 * @createDate: 2025-12-18 20:26
 * @Since: 1.0
 */
@EnableResourceServer
@EnableGlobalMethodSecurity(prePostEnabled = true)
@Configuration
@Slf4j
public class ResourceConfig extends ResourceServerConfigurerAdapter {
    @Override
    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {
        resources.tokenStore(jwtTokenStore());
    }

    /**
     * 配置JWT解析
     *
     * @return
     */
    private TokenStore jwtTokenStore() {
        JwtTokenStore jwtTokenStore = new JwtTokenStore(getJwtAccessTokenConverter());
        return jwtTokenStore;
    }

    /**
     * 注意这个converter必须要添加@Bean，被IOC扫描到
     * @return
     */
    @Bean
    public JwtAccessTokenConverter getJwtAccessTokenConverter() {
        JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter();
        ClassPathResource classPathResource = new ClassPathResource("coinexchange.txt");
        //配置JWT的公钥
        String publicKey = null;
        try {
            byte[] bytes = FileCopyUtils.copyToByteArray(classPathResource.getInputStream());
            publicKey = new String(bytes);
        } catch (Exception e) {
            e.printStackTrace();
            log.error("Get public key is error [{}]", e.getMessage());
        }
        jwtAccessTokenConverter.setVerifierKey(publicKey);
        return jwtAccessTokenConverter;
    }

    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.csrf().disable()
                .sessionManagement().disable()
                .authorizeRequests()
                .antMatchers("/**").authenticated()
                .and()
                .headers().cacheControl();
    }
}
```



#### 5. JetCache的配置

```java
/**
 * @description: jetcache配置
 * @author: carl
 * @createDate: 2025-12-18 20:21
 * @Since: 1.0
 */
@Configuration
@EnableCreateCacheAnnotation
//设置可以在方法上使用cache
@EnableMethodCache(basePackages = "com.carl.service.impl")
public class JetCacheConfig {
}
```



#### 6. 通用返回结果

```java
/**
 * @description: 通用返回对象
 * @author: carl
 * @createDate: 2025-12-18 20:36
 * @Since: 1.0
 */
public class R<T> implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 成功
     */
    public static final int SUCCESS = CommonConstants.SUCCESS;

    /**
     * 失败
     */
    public static final int FAIL = CommonConstants.FAIL;

    private int code;

    private String msg;

    private T data;

    public static <T> R<T> ok() {
        return restResult(null, SUCCESS, null);
    }

    public static <T> R<T> ok(T data) {
        return restResult(data, SUCCESS, null);
    }

    public static <T> R<T> ok(T data, String msg) {
        return restResult(data, SUCCESS, msg);
    }

    public static <T> R<T> fail() {
        return restResult(null, FAIL, null);
    }

    public static <T> R<T> fail(String msg) {
        return restResult(null, FAIL, msg);
    }

    public static <T> R<T> fail(T data) {
        return restResult(data, FAIL, null);
    }

    public static <T> R<T> fail(T data, String msg) {
        return restResult(data, FAIL, msg);
    }

    public static <T> R<T> fail(int code, String msg) {
        return restResult(null, code, msg);
    }

    private static <T> R<T> restResult(T data, int code, String msg) {
        R<T> apiResult = new R<>();
        apiResult.setCode(code);
        apiResult.setData(data);
        apiResult.setMsg(msg);
        return apiResult;
    }

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }
}
```



#### 7. 通用日志切面

```java
/**
 * @description: 通用日志对象
 * @author: carl
 * @createDate: 2025-12-18 20:37
 * @Since: 1.0
 */
@Data
@EqualsAndHashCode(callSuper = false)
public class WebLog {
    /**
     * 操作描述
     */
    private String description;

    /**
     * 操作用户
     */
    private String username;

    /**
     * 消耗时间/s
     */
    private Double spendTime;

    /**
     * 根路径
     */
    private String basePath;

    /**
     * URI
     */
    private String uri;

    /**
     * URL
     */
    private String url;

    /**
     * 请求类型
     */
    private String method;

    /**
     * IP地址
     */
    private String ip;

    /**
     * 请求参数
     */
    private Object parameter;

    /**
     * 返回结果
     */
    private Object result;

}

//
/**
 * @description: 获取通用日志的切面, 用于logstash
 * @author: carl
 * @createDate: 2025-12-18 20:36
 * @Since: 1.0
 */
@Aspect
@Slf4j
@Component
@Order(1)
public class WebLogAspect {
    @Pointcut("execution( * com.carl.controller.*.*(..))")
    public void webLog() {

    }

    /**
     * 环绕切面
     */
    @Around(value = "webLog()")
    public Object recordWebLog(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        Object result = null;
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        result = proceedingJoinPoint.proceed(proceedingJoinPoint.getArgs());
        stopWatch.stop();

        //获取请求上下文
        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = requestAttributes.getRequest();
        MethodSignature signature = (MethodSignature) proceedingJoinPoint.getSignature();
        Method method = signature.getMethod();
        String className = proceedingJoinPoint.getTarget().getClass().getName();
        String url = request.getRequestURL().toString();

        //获取安全上下文
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

        WebLog webLog = new WebLog();
        //使用userId作为用户名
        webLog.setUsername(authentication == null ? "anonymous" : authentication.getPrincipal().toString());
        webLog.setSpendTime(stopWatch.getTotalTimeSeconds());
        //http://ip:port/admin/list-->http://ip:port
        webLog.setBasePath(StrUtil.removeSuffix(url, URLUtil.url(url).getPath()));
        webLog.setUri(request.getRequestURI());
        webLog.setUrl(url);
        webLog.setMethod(className + method.getName());
        webLog.setIp(request.getRemoteAddr());
        webLog.setParameter(getMethodParameters(method, proceedingJoinPoint.getArgs()));
        webLog.setResult(result);

        log.info("webLog=[{}]", JSON.toJSONString(webLog, true));
        return result;
    }

    /**
     * 获取方法的请求参数
     *
     * @param method
     * @param args
     * @return
     */
    private Object getMethodParameters(Method method, Object[] args) {
        Map<String, Object> methodParameters = new HashMap<>();
        //编译后获取原始的参数名称列表
        DefaultParameterNameDiscoverer defaultParameterNameDiscoverer = new DefaultParameterNameDiscoverer();
        //获取方法中的所有的参数的名称（key）
        String[] parameterNames = defaultParameterNameDiscoverer.getParameterNames(method);
        //参数的值
        Parameter[] parameters = method.getParameters();
        if (args != null) {
            //遍历所有的参数的key,然后将value设置进去
            for (int i = 0; i < parameterNames.length; i++) {
                methodParameters.put(parameterNames[i], parameters[i] == null ? "" : JSONUtil.toJsonPrettyStr(parameters[i]));
            }
        }
        return methodParameters;
    }
}
```



#### 8. 部分全局异常处理器配置

```java
/**
 * @description: 全局异常处理类
 * @author: carl
 * @createDate: 2025-12-18 20:48
 * @Since: 1.0
 */
@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * 内部API调用异常处理
     *
     * @param e
     * @return
     */
    @ExceptionHandler(value = ApiException.class)
    public R handle(ApiException e) {
        if (e.getErrorCode() != null) {
            return R.fail(e.getErrorCode());
        }
        return R.fail(e.getMessage());
    }

    /**
     * 方法参数缺失异常处理
     *
     * @param e
     * @return
     */
    @ExceptionHandler(value = MethodArgumentNotValidException.class)
    public R handleValidException(MethodArgumentNotValidException e) {
        BindingResult bindingResult = e.getBindingResult();
        String message = null;
        if (bindingResult.hasErrors()) {
            FieldError fieldError = bindingResult.getFieldError();
            if (fieldError != null) {
                message = fieldError.getField() + fieldError.getDefaultMessage();
            }
        }
        return R.fail(message);
    }

    /**
     * 使用Valid校验参数的时候，抛出的异常
     *
     * @param e
     * @return
     */
    @ExceptionHandler(value = BindException.class)
    public R handleValidException(BindException e) {
        BindingResult bindingResult = e.getBindingResult();
        String message = null;
        if (bindingResult.hasErrors()) {
            FieldError fieldError = bindingResult.getFieldError();
            if (fieldError != null) {
                message = fieldError.getField() + fieldError.getDefaultMessage();
            }
        }
        return R.fail(message);
    }
}
```




#### 9. mybatis-plus自动填充创建人、更新人等信息

```java
/**
 * @description: mybatis-plus自动填充创建、更新数据
 * @author: carl
 * @createDate: 2025-12-18 23:13
 * @Since: 1.0
 */
@Component
public class AutoFiledValueHandler implements MetaObjectHandler {
    /**
     * 执行插入操作的时候填充
     * @param metaObject
     */
    @Override
    public void insertFill(MetaObject metaObject) {
        Long userId = getUserId();
        //修改时间填充
        this.strictInsertFill(metaObject, "lastUpdateTime", Date.class, new Date());
        //创建人填充
        this.strictInsertFill(metaObject, "createBy", Long.class, userId);
        //创建时间填充
        this.strictInsertFill(metaObject, "created", Date.class, new Date());
    }

    /**
     * 获取用户id
     *
     * @return
     */
    private Long getUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Long userId = null;
        if (authentication != null) {
            String principal = authentication.getPrincipal().toString();
            userId = Long.valueOf(principal);
        }
        return userId;
    }

    /**
     * 执行更新操作的时候填充
     * @param metaObject
     */
    @Override
    public void updateFill(MetaObject metaObject) {
        Long userId = getUserId();
        //修改时间填充
        this.strictInsertFill(metaObject, "lastUpdateTime", Date.class, new Date());
        //修改人员信息填充
        this.strictInsertFill(metaObject, "modifyBy", Long.class, userId);
    }
}
```



---





### 五、后台管理系统模块



​	后台管理系统的开发没有什么特别需要注意的地方，无非就是增删改查操作而已。需要记录的一个点就是，在后台管理系统登录接口中，当获取到了jwt的结果之后，我们**要保存到Redis数据库中**。



```java
@Service
public class LoginServiceImpl implements LoginService {
    @Resource
    private OAuth2FeignClient oAuth2FeignClient;

    @Value("${Authorization:Basic Y29pbi1leGNoYW5nZTpjb2luLXNlY3JldA==}")
    private String authorization;

    @Resource
    private SysMenuService sysMenuService;

    @Resource
    private RedisTemplate redisTemplate;

    /**
     * 登录
     *
     * @param username
     * @param password
     * @return
     */
    @Override
    public LoginResult login(String username, String password) {
        //1.获取token
        String accessToken = null;
        ResponseEntity<JwtTokenVo> response = oAuth2FeignClient.getToken("password",
                username,
                password,
                "admin_type",
                authorization);
        if (response.getStatusCode() != HttpStatus.OK) {
            throw new ApiException(ApiErrorCode.FAILED);
        }
        accessToken = response.getBody().getAccessToken();

        //2.获取菜单列表
        Jwt jwt = JwtHelper.decode(accessToken);
        String claims = jwt.getClaims();
        JSONObject jwtJsonObject = JSON.parseObject(claims);
        String userId = jwtJsonObject.getString("user_name");
        List<SysMenu> menus = null;
        menus = sysMenuService.getMenusByUserId(userId);
        //3.获取权限列表
        List<SimpleGrantedAuthority> authorities = null;
        JSONArray authoritiesJsonArray = jwtJsonObject.getJSONArray("authorities");
        authorities = authoritiesJsonArray.stream().map(item -> new SimpleGrantedAuthority(item.toString()))
                .collect(Collectors.toList());
        //将登录成功之后的token保存到redis
        redisTemplate.opsForValue().set(accessToken, "", response.getBody().getExpiresIn(), TimeUnit.SECONDS);
        //返回bearer token
        return new LoginResult(response.getBody().getTokenType() + " " + accessToken, menus, authorities);
    }
}
```





### 六、会员系统模块

​	在会员系统中我想记录一些Web3的概念。因为Web3是**去中心化**的，**数据权给用户**，所以对于一个用户来说，他可以有多个钱包地址，钱包地址是网络公开的，每个**钱包地址是由公钥通过加密算法加密生成的加密串**，对应的钱包地址的**私钥在用户手里**，只有用户自己可以**通过私钥**找到对应的钱包地址，然后打开对应的钱包然后进行交易。

​	一个用户可以配置多个钱包地址的好处有：

	1. 安全的资产转移
	2. 防止身份被冒用
	3. 多地址管理，一个用户可以拥有多个地址，增加灵活性和安全性
	4. 可以兼容多链以及跨平台：不同区块链可能有不同的格式地址（如BTC地址、ETH地址），但都遵循“**地址即账户**”的范式。用户在不同平台使用同一个地址，资产状态一致，便于资产管理。


​	在会员系统中设计了**用户多级审核**。

​	初级审核：使用阿里云的产品直接审核身份证号和对应的真实姓名是否一致。

​	高级审核：用户上传证件照，由管理员在后台进行人工审核。



​	在会员系统中，发现会员系统和后台管理系统之间可能相互喜欢频繁的feign调用，所以需要配置一个OpenFeign的配置，将access_token放在请求的Header中进行。下面是一个OpenFeign的配置类代码。

```java
/**
 * @description: feign远程调用配置，主要是传递header中的认证token
 * @author: carl
 * @date: 2025.12.26
 * @Since: 1.0
 */
@Configuration
@Slf4j
public class OAuthFeignConfig implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate requestTemplate) {
        //获取请求上下文信息
        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (requestAttributes==null){
            log.error("没有获取到上下文请求信息");
        }else{
            HttpServletRequest request = requestAttributes.getRequest();
            String token = request.getHeader(HttpHeaders.AUTHORIZATION);
            log.info("获取到的用户的认证信息为:{}",token);
            requestTemplate.header(HttpHeaders.AUTHORIZATION,token);
        }
    }
}
```





### 七、财务系统模块



​	财务系统主要负责系统的资产管理，系统的资产分为两类，一类是数字货币，另一类是现金。其他系统要想支出、输入资产都要通过财务系统的审核结算。

​	财务系统的难点主要在于：**要保证数据的强一致性**、保证**锁安全**、**事务保证**



​	币种概念记录：

​	1. GCN:**格罗币**（GameCoin），是一种特定的加密数字货币。主要用于**小额支付**、**在线购物**、**游戏道具购买**和**虚拟物品交易**，特别适合需要**快速处理**和**低费用**的场景

​	技术特点：

​	基于Scrypt算法
​	是Litecoin/Dogecoin的克隆
​	交易速度快，费用低
​	具有较高的匿名性，保护用户隐私
​	有良好的可扩展性，能处理高交易量

​	

​	在虚拟货币交易系统中，法币这个概念指的是：**各个国家法定货币**。比如中国：人民币，美国：美元





### 八、撮合引擎模块

​	撮合引擎模块是整个货币交易系统最核心的模块，而且撮合引擎的效率会直接影响到买入和卖出委托单的成交效率，而且必须要保证高并发。而且**撮合引擎一般都是通用的不要和业务有强耦合**，下面我就通过一幅图片来说一下我们系统中的撮合引擎的设计思路。

![撮合引擎实现流程](https://s3.bmp.ovh/imgs/2026/01/07/335cef7161f1227f.png)





> 项目代码已经开源，对应的github地址如下：
>
> https://github.com/CarlLy7/coin-exchange
> 大家如果喜欢记得给一个Star!!!