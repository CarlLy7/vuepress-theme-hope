---
title: 分库分表方案中遇到的问题以及解决方案
date: 2026-01-27 20:00:48
icon: hammer
---

## 分库分表方案中遇到的问题以及解决方案

#### 遇到的问题

1. **JOIN 联查的时候会遇到跨库 JOIN 的情况**
2. **会遇到分布式事务问题**

---

#### 解决方案

**针对跨库 JOIN 联查问题的解决方案**

1. 如果我们需要进行联查的数据确实存在跨库的情况的话，那么我们就不能直接使用 SQL 层的 JOIN 联查了，我们**需要在上层也就是应用层进行处理**，比如 Service 层分别去两个库进行查询，然后将查询出来的数据进行匹配关联。

2. 如果是一些更加复杂的查询，比如一个报表需求的话，那么可能就需要借助于搜索引擎，比如 ES 来进行查询，然后封装成最终的报表
3. 可以设计大宽表，也就是一个表中不让它满足第三范式了，而是进行一些冗余，比如在订单表中存储一些商品基本信息，这样通过订单查询商品信息的时候就可以避免联查了，但是这种大宽表方案有个问题

::: warn

数据一致性问题，因为我们做了数据冗余，我们这个大宽表中存的商品信息可能已经发生了变更，那么就出现了数据一致性问题了，一般还是需要在应用层再进行一次查询然后匹配来保证数据的一致性的。

:::

4. 使用开源框架 ShardingSphere(推荐)

​ 天生支持跨库 JOIN 的解决方案，可以将你的查询进行**拆解-路由-结果聚合**来解决跨库 JOIN 问题。

**针对分布式事务的解决方案**

1. **2PC**
   两阶段提交方案，这种方案是数据库层支持的，而且对于代码的侵入度很小，开发成本比较低，会保证事务的**最终一致性**。
2. **TCC**
   使用补偿事务的方案来保证事务的一致性，但是三个阶段**Try-Confirm-Cannel**需要我们手动编码实现，对于代码的侵入度比较高。
3. **使用开源框架 Seata(推荐)**

​ Seata 中有**AT 模式**来实现 2PC，对于你开发来说，代码侵入度非常低，你配置好 Seata 之后，只需要在需要保证事务的地方使用一个注解**@GlobalTransactional**就可以实现，而且 AT 模式的性能是比较高的，基本能够使用绝大部分的分库分表的事务场景。但是 AT 模式只保证了**最终一致性**，对于一些一致性要求非常高的场景比如金融业务，那么你就需要使用一致性强的 TCC 模式了

::: tip

补充： AT 模式依赖于 undo log 日志来进行事务的回滚，他会将 undo log 进行持久化。

:::

​ Seata 中的**TCC 模式**就是上面说的 TCC 的实现，需要我们自己手动的去写三个阶段的代码，对于代码的侵入性比较高，而且非常的考验程序员的功底，比如你需**自行处理幂等、空回滚、悬挂等问题**，还需要**在 Try 阶段预留跨库/跨表的资源（比如锁定库存**），开发成本很高。

​ 针对于长事务，Seata 中还有**SAGA 模式**支持。SAGA 模式使用了“**补偿事务**“来实现的最终一致性。执行过程分为两个阶段。
​ 第一个阶段：**正向阶段**：按照固定的顺序（T1->T2->T3）进行执行，每个步骤**仅执行本地事务并提交**，无锁。

​ 第二个阶段：**反向阶段**：如果事务出现问题，按照相反的方向进行事务补偿(T3 事务补偿->T2 事务补偿->T1 事务补偿) 恢复到最初的事务前的状态。

::: tip

**SAGA 模式，需要手动写正向逻辑+手动写反向补偿逻辑，不依赖于 undo log 日志**

:::

4. 使用分布式数据库 TiDB

​ 透明化处理了跨库查询和分布式事务问题。但是需要付费
