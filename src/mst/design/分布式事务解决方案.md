---
title: 分布式事务解决方案
date: 2023-12-01
icon: eos-icons:patch-fixes
---



## 分布式事务解决方案



#### 本地数据库事务

本地数据库事务就是我们最常见的普通的本地事务，如果只涉及到一个数据库的话，那么所涉及的事务就可以简单的说是本地数据库事务。本地数据库事务遵循的原则就是ACID。

- A：原子性

​	将一组操作看成一个整体原子操作，要么全部执行完成，要么都不执行

- C：一致性

​	操作执行完前后数据保持一致，比如转账前后金额的总数应该是不变的，有人的账户多了100，那么就有人的账户少了100

- I:隔离性

​	隔离性就是一个事务对其他事务是不可见的，并发访问数据库的时候，一个事务不被其他的事务干扰

- D:持久性

​	事务提交之后是持久性的，即使数据库宕机了重启之后数据依然是提交之后的数据



#### 分布式事务



分布式事务不同于简单的本地数据库事务，简单的来说分布式事务就是一个操作涉及到多个数据库的时候的事务。对应的分布式事务的理论就不是ACID了，而是CAP理论和Base理论。



##### CAP理论

CAP理论是分布式系统的一个基本的理论，现在的分布式系统的设计都需要围绕CAP理论，但是CAP理论在现在的系统中只能取其二，而不能同时满足CAP，下面介绍一下什么是CAP理论

- C：一致性

​	多个节点访问的是同一份数据

- A：可用性

  当分布式系统中某个节点出现故障之后，整个系统依然可用

- P:分区容错性

​	因为网络问题导致分布式系统出现网络分区之后，仍然可以对外提供服务。



在现在的分布式系统中，CAP中我们必须要保证的是P也就是分区容错性，因为对程序员来说网络问题是不能保证的，所以分区容错性是分布式系统中必须保证的，所以P是必须的。两外的C和A只能保证一个。保证了C就不能保证可用性，因为要想一致性就需要所有的节点都可用，所以不能满足可用性。如果想要可用性就不能保证所有节点读到的是同一份数据因为可能有的节点已经挂掉了。所以A和C只能取其一。

所以现在的分布式系统都是AP或者CP原则的。



##### Base理论

Base理论就是最终一致性，不保证实时性，而是保证在一定的时间内最终一致即可。



##### 一致性的三个级别

- 强一致性

​		顾名思义“强”，就是写入什么立刻读到什么

- 弱一致性

​		写入一个数据后，不保证在一定时间内看到最新的数据，不确定什么时候可以看到最新的数据。

- 最终一致性

​	 	写入数据之后，保证在指定的时间内可以看到最新的数据。



##### 常见的分布式解决方案

2PC、3PC、TCC、MQ、本地消息表、Saga等

两阶段提交和三阶段提交中的角色说明：

1. TM:事务管理者
2. RM:事务参与者，一般就是指数据库
3. AP:应用程序本身



- 2PC：两阶段提交方案

​	两阶段提交方案对业务代码没有侵入性，依赖存储层的事务机制。

​	流程：

​		1、准备阶段

​			TM向所有的RM发送一个准备命令，然后所有的RM去执行一个数据库事务的预操作比如写redo/undo log，执行完成之后给TM发送一个ACK消息。如果TM没有收到所有RM的ACK消息的话，会给所有的RM发送消息让他们去回滚，RM回滚完成之后给TM发送一个ACK消息，当TM收到所有的ACK之后中断事务

​		2、提交阶段

​			TM收到了所有RM的准备就绪ACK消息之后，给所有的RM发送提交命令，所有的RM就回去执行业务并且提交，提交完成之后返回ACK消息。如果TM收到了所有RM的ACK消息之后，TM结束事务。如果TM没有收到所有RM的ACK消息的话，给所有的RM发送回滚命令，所有的RM进行回滚操作，释放掉资源，然后完成回滚的RM给TM发送一个ACK,当TM收到所有RM的回滚ACK之后，TM将事务中断。

​	![2pc-work-flow](https://cdn.jsdelivr.net/gh/EyeDroplyq/myblog-img@master/2pc-work-flow.png)

	##### 2PC的缺点：

1. 同步阻塞，在正式提交事务之前会一直占用数据库资源
2. 会有数据不一致问题，比如在提交阶段因为网络问题，一些RM没有收到提交或者回滚命令的话，就会导致数据不一致问题
3. 单点问题：当准备阶段接收之后，TM宕机，RM因为收不到TM的命令会一直卡在提交阶段





- 3PC：三阶段提交方案

​	在2PC的基础上进行了改进，引入了超时机制，将原来的二阶段分成了三阶段

1. 准备阶段

​		准备阶段TM会向所有RM发送准备请求，RM会根据可以能否执行事务给TM返回yes or no or 超时未回复。如果有一个RM返回了no或者超时未返回的话，TM会直接给所有的RM发送Abort中断请求。RM收到Abort消息之后直接中断事务。

​		如果所有的RM都给TM返回了yes的话，进入预提交阶段。



2. 预提交阶段

​		TM给所有的RM发送预提交命令，所有的RM接收到预提交命令之后，去执行数据库事务的预操作，比如写redo log/undo log日志。如果成功执行了的话返回yes,否则返回NO,在预提交阶段TM和RM都引入了超时机制。当在预提交阶段有RM给TM返回了no或者超时未返回的话，TM给所有的RM发送Abort命令，就会中断事务，释放资源。

​	如果所有的RM都给TM返回了yes的话，进入提交阶段。



3. 提交阶段

​	TM给所有的RM发送DoCommit命令，所有的RM去执行业务并且提交事务，提交成功之后返回yes,失败的话返回No

​	如果TM超时没有给RM发送DoCommit命令的话，RM会自动提交事务。

​	如果有RM给TM发送了no的话，TM会给所有的RM发送Abort命令，所有的RM会进行回滚。释放资源，整个事务进行中断。

![3pc-work-flow.png](https://cdn.jsdelivr.net/gh/EyeDroplyq/myblog-img@master/3pc-work-flow.png)

##### 3PC的缺点

1. 性能糟糕
2. 依然存在数据不一致问题：比如在PreCommit阶段，RM接收到TM的PreCommit命令之后因为网络问题发生了网络分区，此时TM和RM没法通信了，RM依然会提交，但是可能此时TM要求其他的RM回滚了。这就会出现数据不一致问题。



- TCC：补偿事务

​	补偿事务又叫做最大努力通知，保证了最终一致性。TCC是Try-Confirm-Cancel的缩写。分成了三个阶段Try|Confirm|Cancel

​	Try:尝试执行，完成业务检查，并预留好所需要的资源

​	Confirm:确认执行。当所有的事务参与者的Try执行完成之后就执行Confirm

​	Cancel:取消执行，释放Try阶段中预留的资源



Try阶段失败的话会去执行Cancel阶段的业务，那么Confirm和Cancel阶段失败的话，TCC会将事务日志保存到存储媒介上比如本地文件，数据库、zookeeper等，事务日志中会记录事务的执行状态，如果失败了会记录具体失败在哪一步。然后会根据这个日志文件去对应的Confirm阶段或者Cancel阶段进行重试，一般如果重试6次之后依然没有成功就需要人工介入了。



##### TCC的缺点

TCC中的Try、Commit、Cancel都需要我们自己写，对业务代码有侵入性



##### TCC的优点

TCC不会一直持有各个业务资源的锁，追求的是最终一致性。



- MQ:消息队列事务

  消息队列事务我个人理解为也是最终一致性的方案。RocketMQ,QMQ,Kafka都提供了事务相关的功能，将消息生产、消费、处理过程可以定义为一个原子操作。

  ![MQ事务.png](https://cdn.jsdelivr.net/gh/EyeDroplyq/myblog-img@master/MQ事务.png)

​	我理解消息队列事务其实也是利用了2PC的思想，说一下

1. 生产者给消息队列中发送一个半消息，在生产者将本地事务提交之前消费者是看不到这个半消息的
2. 生产者就去执行本地事务了
3. 如果本地事务执行成功给队列发送Commit如果失败给队列发送Rollback
4. 当队列收到Commit后，将半消息变成正常消息，对消费者可见，消费者去消费。然后队列收到了Rollback的话，直接回滚。队列不投递消息。



为了防止生产者给消息队列发送commit或者rollback消息失败的问题，所有消息队列会定时去生产者上查这个事务的执行状态。并根据这个结果决定是提交还是回滚。

如果正常消息没有被消费的话会将消息放到私信队列中，如果重试超过几次之后依然没有被消息就需要人工介入了。



如果我们使用的是RocketMQ来实现消息队列事务的话，如果队列挂了那么整个应用就挂了。所以推荐使用QMQ来实现，因为它使用的是本地消息表原理，即使队列挂了也不会导致整个应用挂掉。



QMQ的本地消息表就是将分布式事务拆成本地事务来处理。将消息的发送状态保存到本地消息表的操作和业务操作放到一个事务中执行。然后启动一个线程去定时轮询本地消息表，将本地消息表中没有处理的消息放到消息队列中去处理。当消息发送成功之后，更新本地消息表中的消息状态或者直接将消息删除掉。



END......





