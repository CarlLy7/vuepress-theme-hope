---
title: 秒杀系统的设计方案
date: 2023-11-26
icon: eos-icons:file-system
---



## 秒杀系统的设计方案



对于一个秒杀系统来说，最关键的肯定是大并发量了，秒杀系统就是典型的互联网三高系统的一个应用。三高分别是：高并发、高性能、高可用。



#### 1、热点数据处理

##### 静态热点数据处理

对于一个秒杀系统来说肯定会产生热点数据。比如要进行秒杀的商品就会变成一个热点数据，在短时间内会有非常非常大的流量。

所以我想第一步就是先处理热点数据。对于秒杀系统来说，这个热点数据我们程序员其实是知道的，因为我们要秒杀什么商品是确定的，所以我们可以提前进行准备来防止我们的系统崩溃掉。对于秒杀商品需要的静态资源，比如html、css、js来说我们可以使用静态热点数据处理法来处理。比较成熟的技术就是使用CDN来处理静态资源的热点数据。我们可以使用稳定的云厂商的服务比如阿里云、腾讯云、华为云、青云等



##### 动态热点数据的处理：

有很多场景下其实都是动态热点数据，意思是：我们没办法提前知道哪些数据是热点数据。对于这类热点数据我们称之为动态热点数据。对于动态热点数据的处理方法，我们需要有热点数据监测的能力。来实时监测系统中的数据，来及时的发现哪些数据是热点数据。

热点数据监测工具可以使用京东开源的hotkey中间件，如果我们使用了redis作为缓存的话，我们可以使用redis的热key监测技术来监测redis中的热key来及时发现热点数据。



我们一般会将热点数据放到缓存中去，但是如果仅仅使用类似于redis这样的缓存中间件来缓存热点数据的话redis集群很可能会被干掉了。所以我们会将并发量非常非常大的数据考虑放到jvm内存中去，因为在jvm内存中是最快的，没有网络开销。



redis的热key探测方案：

1、修改redis的sdk，记录每次请求，定时将收集到的请求上报，然后做一个统一的处理。

2、**代理层上报**：如果所有的请求都走代理层的话，可以在代理层进行请求的收集然后进行上报，然后再由外部的其他系统进行解析分析和计算

3、redis定时扫描：redis本身有命令可以来扫描整个keyspace的热key,这个命令是redis-cli --hotkeys，但是这个命令耗时太久，耗时和redis中缓存的数量成正比。所以性能比较差。

4、Redis节点抓包分析：在可能存在热key的节点上进行抓包，然后进行分析、计算。但是有一个问题，对于一个热key的redis节点来说，请求量是非常大的，如果我们还进行抓包的话，可能更加影响性能，会使情况更加糟糕。





#### 2、高可用



保证高可用的话，我们一般就是使用集群来进行处理。比如对于缓存来说，如果我们使用的是redis的话，我们可以使用redis的sentinel哨兵模式来搭建redis集群来提高系统的可用性，让我们的系统实现高可用。

 为什么不使用redis的一主多从技术呢？因为如果一个master宕机之后，一个slave变成了master的话，我们需要手动的去修改客户端访问master的地址，另外还要让其他的slave去复制这个新的master的数据。这都需要人工手动干预，而使用sentinel哨兵模式的话，可以自动实现，不需要手动人工干预。





#### 3、高并发



##### 1、限流

解决高并发的一个偷懒的办法就是来进行限流了，我们来规定最大流量，让流量在系统可以接收的范围之内，这样我们的系统就不会崩溃。当超过流量的时候给用户一个友好的提示，让用户知道当前自己没法访问，过会再来访问。

针对与秒杀系统这个场景来说的话，我们可以在秒杀开始之前进行预约，这样就可以大致的估计到会有多少流量了。其次为了防止有人使用脚本来进行秒杀，我们可以使用用户输入验证码的方式来进行流量的限制以及脚本的判断。

目前进行限流的中间件也有很多，比较推荐的是阿里巴巴的sentinel。简单而且功能强大，经历过双十一的考验。我们可以对接口进行流量的限制，也可以针对用户或者ip地址来进行流量的限制来保证每个用户只能秒杀一个商品。使用sentinel的话就都可以实现了。



##### 2、流量削峰

**注意：如果我们使用了限流的话，那么我们就没有比较使用流量削峰了。如果我们没有使用限流的话，那么流量削峰就很有必要了。**

如果流量很大我们没办法立刻消费，同时我们不希望我们的系统崩溃的话，我们可以使用消息队列来进行流量削峰。简单来说就是将大量的请求直接丢到消息队列中，然后后台服务器慢慢的去消费，这样我们的服务器就不会因为大流量发生崩溃。



##### 3、降级

降级是从系统的优先级角度来说的，比如当流量剧增的时候，系统会将一些无关紧要的功能进行关闭或者降级来优先保证优先级高的功能的可用性。



##### 4、熔断

熔断和降级是有点类似的，所以很多人经常弄混。 降级主要是应对系统本身的故障，而熔断主要是应对系统依赖的外部系统或者第三方系统的故障。

举个例子：秒杀服务在服务A上，同时服务A上有其他的功能，比如商品管理。当秒杀的大流量来到服务A上的时候，服务A提高商品管理功能就会很慢很差，这个时候使用熔断让其他的服务不来服务A上访问服务A的商品管理功能，这样就可以有效的防止其他服务因为服务A的商品管理性能慢而拖垮其他的系统。



##### 5、一致性

设计秒杀系统的时候一个关键的问题就是防止超卖问题的出现。

现在常用的扣减库存的方案有两个：一是下单的时候就扣减库存，没有付款也扣减库存。二是付款之后才扣减库存。

如果下单就扣减库存的话，当一定时间内用户没有付款的话我们不应该去扣减库存的。如果我们系统使用的redis来作为缓存的话，我们可以使用lua脚本来保证下单和扣减库存的原子性。



##### 6、幂等性

何为幂等性：用户多次发起同一个相同的请求的时候等到的结果和发出单个请求是一样的。

在设计秒杀系统的时候我们也要考虑幂等性。比如当用户多次下单我们只会让他购买一个秒杀商品，不可能是下单几次买几个。另外比如支付按钮，用户可能因为网络问题多次重复点击了同一个付款按钮，我们不能多次扣费，只会扣一次费用。

幂等性的实现可以使用分布式锁来实现，也可以使用token+redis的方案来实现。





#### 总结：

在上面的这个秒杀系统的设计方案中，只是大体提供了一个方向，但是里面的很多具体细节没有详细展开，举个简单的例子，使用消息队列来进行流量削峰的时候的消费顺序，消息堆积问题等如何解决，保证一致性的时候如何解决，以及幂等性如何具体实现因为篇幅问题都没有详细展开，后序可能会在后面的文章中详细说明。





END....







