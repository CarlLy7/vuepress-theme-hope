---
title: 缓存和数据库数据一致性问题解决方案
date: 2024-03-24
icon: eos-icons:network-file-system

---



## 缓存和数据库数据一致性问题解决方案



#### 写在前面

 在系统开发过程中我们经常会为了提高系统的吞吐量而引入缓存，降低数据库访问的压力，那么引入一个新的组件，势必会带来新的问题，其中比较常见的一个问题就是缓存和数据库中数据的一致性问题了。 通俗的来说也就是： **先更新数据库还是先更新缓存**
	

​	常见的缓存和数据库数据的更新有两大类分别是：

​		1、**写时缓存**

​		2、**读时缓存**



#### 一、写时缓存

​	![](https://s3.bmp.ovh/imgs/2024/03/24/bcb3d260988f26e6.png)

​	写时缓存就是 **先更新数据库，然后再更新缓存** ，这种方案有个问题，那就是 **容易出现读到脏数据的问题** ，比如一个线程更新完数据库后还没有更新完缓存，此时有另一个线程来读取缓存，那么就会读取到之前的老数据。

​	但是写时缓存的这个问题也不是没有解决办法，那就是 **通过加锁，让更新数据库和更新缓存同时只能有一个线程来操作** ，但是这个解决方案的显著问题就是系统性能会变得很差。但是并不是说这种方案没有好处，它的好处就是 **数据的实时性强** 。线程读到的一定是最新的数据。对于**对数据一致性有很强要求**的场景比如 ‘金融系统’，这种方案是可以考虑的。

​	但是这种方案还有一个缺点就是： 如果对缓存的更新失败，**需要写操作才能重新操作缓存** ，但是对于大部分业务来说，都是读多写少。这个原因其实也是写时缓存方案使用少的 **主要原因** 。

​	

#### 二、读时缓存

​	读时缓存就是 **先更新数据库，然后将缓存删除，等下次读取操作到来时，去更新最新的缓存数据** 。

​	这种方案也是无法完全避免读到脏数据的问题的，因为在更新数据库和删除缓存之间，另外的读取依然可以读到脏数据。但是相比于写时缓存方案，读时缓存方案 **如果操作缓存失败，那么下一次的读请求会重新操作缓存** ，同时大部分业务都是读多写少，所以这种方案在公司里使用的更多。

​	最简单的读时缓存方案对于 **单机的数据库** 来说是可以的，但是如果是对于 **主从架构** 的数据库来说， **可能不太适用** ，因为会带来更多的读取脏数据问题。

​	简单的读时缓存方案原理图：

​	![](https://s3.bmp.ovh/imgs/2024/03/24/c69b0caf85f31dc4.png)

​	

​	对于 **主从架构** 的**数据库**来说，应该使用 **延迟双删和订阅binlog删除缓存** 这两种读时缓存方案来解决。

​	1、==延迟双删方案==

​				**更新数据库的时候，删除缓存** ，同时可以引入消息中间件mq来 **发送一个延迟消息** ， **延迟一个时间之后再去删除一次缓存** 。这种方案是为了 **保证最终一致性** ，对于强一致性的实现支持不太好。

​			主从架构的数据库的延迟双删流程图：

​		![](https://s3.bmp.ovh/imgs/2024/03/24/dce3af79617fd453.png)



​	2、==订阅binlog删除缓存方案==

​				**更新数据库的时候，等到slave数据库接收到master的binlog之后再去删除缓存** 。这种方案也是为了 **保证最终一致性** ，对于强一致性的实现支持不太好。

​				订阅binlog删除缓存方案的流程图：

![](https://s3.bmp.ovh/imgs/2024/03/24/6f17637f5a5b074c.png)



​	**读时缓存方案比较适用于读多写少，并且对于数据的一致性要求不是很高的业务场景**





#### 总结

​		对于写时缓存还是读时缓存方案的选择各有优缺点和适用场景，对于数据库和缓存的数据一致性问题 **没有绝对的银弹** ，**不要觉得写时缓存公司用的比较少就觉得这种方案不如读时缓存方案好** ，要根据你公司项目的具体情况来进行选择。

