---
title: Feed流/信息流 系统设计方案
date: 2023-12-01
icon: eos-icons:symlink
---



## Feed流/信息流 系统设计方案



#### 何为feed流/信息流?

简单的来说，能够实时/智能化推荐信息的数据流就是Feed流/信息流。常见的比如：微信朋友圈、微博关注、头条首页等



#### 如何设计？

设计Feed流/信息流有两个角度，第一个是实时性，就是简单的根据时间的先后顺序来进行推荐，这种方案比较简单实现。

另一个角度就是智能化推荐，可以根据用户的喜好来进行推荐用户喜欢的内容，这也是信息时代“信息茧房”的由来。你只能看到你喜欢的东西，看不到其他的很多东西。这种方案一般是需要结合推荐系统来实现的。推荐效果的好坏直接由推荐算法来直接决定。



但是我感觉基于时间+智能化推荐的组合是比较好的，既能看到自己喜欢的内容，又不会太容易产生“信息茧房”。



**基于时间（TimeLine）的Feed流**

常见的比如微信朋友圈，微博关注列表的动态，是根据时间来进行推荐的。我们优先看到的是最新的内容。这种比较容易实现。





#### Feed流系统的注意事项

##### 1、实时性

当我们关注的人发布了内容之后我们应该实时的看到最新的内容，所以对于实时性的要求很高。

##### 2、高并发

举个简单的例子，对于微博来说，所有用户打开微博之后进去先看到的就是推荐的页面，也就是feed流推送过来的数据，所以这个并发量是很大的。

##### 3、高性能

还是用微博来说，对于推荐的页面的显示，微博可能需要聚合非常多的信息，所以性能的高低直接决定了用户的体验感，所以对于性能有很高的要求。



#### 设计Feed流数据的几种推送模式

##### 1、推模式(写扩散)

以微博为例，当一个up发表了一个动态之后，会将这个动态同时发送给所有关注了他的用户。所以这种模式叫做推模式。

![推模式](https://cdn.jsdelivr.net/gh/EyeDroplyq/myblog-img@master/Feed流的推模式.png)

**问题**：这种模式有一个很大的问题，如果当前发布动态的up是一个大V，拥有几千万的粉丝的话，如果他发布一条动态给所有关注他的用户推的话，那么会产生大量的插入语句，而且性能也是很差的。存储成本太高。所以不适合粉丝数很多的大V。



##### 2、拉模式(读扩散)

以微博为例，一个用户登录之后会去主动拉取他关注的up的最新的动态。

![拉模式](https://cdn.jsdelivr.net/gh/EyeDroplyq/myblog-img@master/Feed流的拉模式.png)

**问题**：拉模式依然有问题，如果一个用户关注的人非常多，那么在他登录的时候，feed流会去拉取非常多的数据然后再进行数据的聚合然后再给他显示出来，这个过程可能耗时比较多，所以性能就会差点，给用户的体验感就不是很好了。查询和聚合的成本太高，而且拉模式比推模式的实时性更差。

​	而且拉模式还有一个很致命的问题，很容易是我们系统的故障点的就是：对于一个大V来说，它需要记录每个用户读到的数据的位置，这个数据量是很大的，也是很容易出问题的地方。每个关注者读取这个大V的数据的位置可能都不一样。





##### 3、推拉结合的模式(读写扩散)

以微博为例，推拉结合的模式的核心是针对大V和不活跃用户来进行处理的。首先指定两个指标，一个来指定多少用户数是大V，另一个用来指定登录频率多少为活跃用户。

当大V在发布动态的时候，会将动态使用推的模式发送给他的粉丝中的活跃用户，对于不活跃的用户使用拉的模式来获得他关注的up的动态。

![Feed流推拉模式](https://cdn.jsdelivr.net/gh/EyeDroplyq/myblog-img@master/Feed流推拉模式.png)



##### 三种模式的小总结：

1、如果我们的系统中用户之间是双向关系，也就是双向关注的话，不会存在大V，所以推荐使用推模式（写扩散）

2、如果我们的系统中是单向关系，并且用户数小于1000万的话，虽然有大V的存在，但是数据量不大，所以也是推荐使用推模式

3、如果我们的系统用户之间是双向关系，并且用户数大于1000万的话，有数据量大的大V存在了，所以推荐使用推拉结合的模式。

4、永远不要只用拉模式

5、对于初创企业可以使用推模式快速开发上线，然后在产品的迭代过程中随着用户数的不断增加当用户数超过1000万的时候再慢慢由推模式演进到推拉结合模式。



##### 数据量

因为对于微博这种社交平台来说，大V的帖子下面可能评论数非常多，所以对于这种大数据量的数据，可以使用mysql+redis的方案，也可以使用mongodb来存储帖子的信息。

如果使用的是MySQL的话，为了提高性能我们可以使用读写分离，分库分表的技术来提高性能和存储量。

另外一个方案是可以使用PingCAP开发的TiDB（分布式数据库）来存储。具备水平扩缩容、金融级高可用的特点。

推模式、拉模式、推拉结合模式都是针对基于时间的Feed流系统来说的。



##### 数据层面

从数据层面来看，feed流系统的数据可以简单的分为三类，分别是：1、发布者的数据 2、用户关注关系 3、接收者的数据

针对这三类数据我们可以有如下的表的定义：

1、存储表：存储发布者的数据，永久保存

2、关系表：存储用户之间的关注关系，永久保存

3、同步库：存储接收者按照时间接受到的数据，一般只需要保留一段时间的就可以，不需要永久保留。



##### feed流系统的元数据

1、用户详情和列表

2、关注或者好友关系

3、推送session池



前两个很好理解，重点说一下第三个推送session池。

举个例子：一个用户发布消息之后要推送给很多用户，那么一个用户是如何知道自己有新消息到来的呢？定时去查询？如果是定时查询的话，那么读请求压力和客户端的数量成正比，如果平常设备的登陆率是20%，某天有一个热点消息到来，大量的设备都登陆了，达到了90%以上，那么这么多的查询请求会产生查询风暴，会将系统干崩溃。

我们session池就是解决这个问题的：session池中可以存储当前登录的设备session信息，当一个用户发布了一个消息之后，不仅将数据保存到存储库和同步库中，然后去session池中通知关注了这个用户的**此时在线的用户**，告诉它你有新消息了，去接收一下。





##### 删除feed内容

对于大V来说发布一条消息后会进行写扩散，那么删除的时候是不是也要写扩散呢？如果删除也是写扩散的话没法满足删除之后立刻删除，对于一些比如艺人有不良行为然后快速删除这个用户的信息来说是没办法立刻实现的。那么应该如何实现呢？在设计同步库的时候，我们这个同步库只保存user_id和消息id,不存放消息内容，我们会根据这个消息id去发布者的存储库中查询内容，所以我们可以直接将发布者的存储库中的消息删除/逻辑删除就可以了，这样同步库通过消息id是看不到消息的内容了。



##### 更新feed内容

更新内容和删除feed内容一样，只需要更新发布者的存储库中的消息内容就可以了。同步库中是不存放消息的内容的。只存放消息的id





END....