---
title: MySQL主库故障之后如何进行故障转移
date: 2026-01-26 20:48:48
icon: highlighter
---

## MySQL 主库故障之后如何进行故障转移

首先这个问题要从大方向来说要从三个方向来看，**① 故障检测 ② 故障转移 ③ 数据一致性检测与同步**

当然大家肯定能猜到，目前市面上肯定是有比较优秀的开源工具的（后面会说），是不需要我们手动去造轮子的。但是面试官问你这个问题的时候肯定是想靠你的思路，也就是问你这些开源工具的实现思路是什么，那么你就需要能够给面试官说出来你的设计思路。

---

#### 故障检测

首先我们肯定要设计一种比较可靠的检测机制，能够**即时且准确**的发现 Master 故障了，既不能够误判也不能够漏判。

**阶段 1: 基础心跳检测**
以一定的时间间隔对 Master 发起心跳检测，比如以 3s 作为时间间隔发送心跳

    1. **尝试与Master的3306端口建立TCP连接**

2. 如果成功与 Master 建立了 TCP 连接，那么可以去**发送轻量级的查询**，比如 Select 1 from table;
3. **尝试与 Master 建立 SSH 连接，去登录 Master**
4. **同时监控 Master 机器的 CPU 利用率、内存利用率、磁盘 IO 等，这个可以帮助我们更好的判断 Master 是否真的出现故障**

::: tip

如果在阶段 1 的**任何一个环节成功了**，那么就认为 Master 是没有故障的

:::

**阶段 2：故障怀疑**

如果我们阶段 1 的三个环节都失败了，那么可以调整时间间隔，由原来的 3s 变为 1s,如果在重复阶段 1 的过程中有一步成功了，那么依然不认为 Master 故障，可能是因为网络抖动引起。如果在经历了 N 次重试之后，阶段 1 的三步都没有成功，那么可以进行阶段 2 了。

与所有的 Slave 建立 SSH 连接，在 Slave 上执行`SHOW SLAVE STATUS`,判断一下 Slave 是否能够成功与 Master 建立连接以及是否能够拉取到 Binlog 日志，如果所有的 Slave 都与 Master 连接超时，并且都没有获取到 Binlog 日志，那么就认为 Master 发生故障了。

::: tip

补充一下：我们要借鉴 Redis Sentinel 的思路，我们的这个检测以及进行故障转移的”Sentinel 节点“，也要部署多个，防止发生”主观下线“的问题。

:::

---

#### 故障转移

在经过前面的故障检测之后，我们可以认为 Master 发生故障了，那么接下来就是进行故障转移，从 Slave 中选择一个来作为新的 Master。

另外进行故障转移的时候可以分为两类。第一类：**人工处理**。第二类：**自动转移**。

其中人工处理就是人工去选择一个 Slave 然后将它作为新的 Master，这里就不详细说明了。下面详细说一下自动转移。这个肯定用的比较多，因为我们的目的其实是想实现自动化处理，**将人”解放出来“，避免 007**。

自动转移：

1. 首先要先通过**Raft 算法**在我们的”Sentinel 集群“中选出一个 Leader 来进行故障转移
2. **可以在 Slave 中选择 Binlog 同步程度最高的 Slave 来作为新的 Master**

但是此时可能还面临一个问题，**脑裂**问题。

::: tip

脑裂问题：因为网络原因导致 Master 和 Slave 之间发生了网络分区，Slave 服务连接到 Master 但是此时的 Master 没有宕机，此时认为 Master 宕机了，选择了一个新的 Master，导致 MySQL 集群中出现了两个 Master 的情况。

:::

我们还需要设计脑裂问题的防御手段

1. **设计”Sentinel 集群“，可以有效的降低风险**
2. **通过 脚本连接 Master 服务器，然后将 Master 强制设置为只读**
3. **通过脚本连接 Master 服务器，然后强制杀掉 3306 端口的进程**

---

#### 数据一致性检测与同步

我们完成故障转移之后还需要进行数据一致性检测与同步。因为老 Master 在宕机之前可能还执行了一些事务，只不过那些事务没有通过 Binlog 同步给 Slave,所以 Slave 中可能会缺失一些数据。

**等老 Master 恢复后需要将它当时已经执行的事务但是没有通过 Binlog 同步给 Slave 的事务在新的 Master 中进行重放**。

这个的实现思路可以利用 Mysql 自带的**GTID（全局事务 ID）**，MySQL**自带**了全局事务 ID，给每一个事务分配一个全局的唯一 ID，我们可以遍历老 Master 的所有 GTID 然后和新的 Master 的 GTID 进行**比较**，只需要去重放新 Master 中**不存在的**GTID 就可以了。

---

#### 开源的故障转移工具推荐

1. **MGR**
   MySQL 8.0.22 之后自带的故障转移机制，如果你的数据库选择的版本达到了要求，并且是新建 MySQL 集群的化可以考虑这个

2. **Orchestrator**
   基于 Go 语言编写的，适合现有的 MySQL 集群进行故障转移，有对应的 Web 界面，交互好，主打**拓扑可视化 + 智能故障切换 + 复制管理**，社区活跃、部署灵活。

3. **MHA**
   老牌 Perl 脚本集，专注主库故障后的自动切换，强调**数据一致性与差异日志补偿**。Mysql5.x 版本自带。

上面说的开源的这些故障转移的工具，其实他们的设计思路和我们上面说的大同小异。
